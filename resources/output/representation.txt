{:ret {:op :if, :form (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))) nil)), :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :test {:args [{:op :quote, :expr {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :type :symbol, :literal? true, :val clojure.core, :form clojure.core, :o-tag clojure.lang.Symbol, :tag clojure.lang.Symbol}, :form (quote clojure.core), :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :literal? true, :children [:expr], :tag java.lang.Object, :o-tag clojure.lang.Symbol}], :children [:instance :args], :instance {:op :quote, :expr {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :type :symbol, :literal? true, :val two-fer, :form two-fer, :o-tag clojure.lang.Symbol, :tag clojure.lang.Symbol}, :form (quote two-fer), :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :literal? true, :children [:expr], :tag clojure.lang.Symbol, :o-tag clojure.lang.Symbol}, :method equals, :op :instance-call, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :o-tag boolean, :class clojure.lang.Symbol, :form (. (quote two-fer) (equals (quote clojure.core))), :tag boolean, :validated? true, :raw-forms ((.equals (quote two-fer) (quote clojure.core)))}, :then {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :type :nil, :literal? true, :val nil, :form nil, :o-tag nil, :tag nil}, :else {:op :do, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :form (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))) nil), :statements [{:args [{:children [:methods], :op :fn, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :o-tag clojure.lang.AFunction, :variadic? false, :methods [{:children [:params :body], :loop-id loop_5141, :arglist [], :params [], :fixed-arity 0, :op :fn-method, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :file "NO_SOURCE_PATH"}, :o-tag java.lang.Object, :variadic? false, :form ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))), :tag java.lang.Object, :body {:args [{:op :invoke, :form (clojure.core/deref (var clojure.core/*loaded-libs*)), :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :fn {:op :var, :assignable? false, :var #'clojure.core/deref, :meta {:added "1.0", :ns #object[clojure.lang.Namespace 0x42ecc554 "clojure.core"], :name deref, :file "clojure/core.clj", :static true, :column 1, :line 2306, :arglists ([ref] [ref timeout-ms timeout-val]), :doc "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?."}, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form clojure.core/deref, :o-tag java.lang.Object, :arglists ([ref] [ref timeout-ms timeout-val])}, :args [{:op :the-var, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form (var clojure.core/*loaded-libs*), :var #'clojure.core/*loaded-libs*, :o-tag clojure.lang.Var, :tag clojure.lang.Var}], :children [:fn :args], :o-tag java.lang.Object} {:op :var, :assignable? false, :var #'clojure.core/conj, :meta {:added "1.0", :ns #object[clojure.lang.Namespace 0x42ecc554 "clojure.core"], :name conj, :file "clojure/core.clj", :static true, :column 1, :line 75, :arglists ([coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type."}, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form clojure.core/conj, :o-tag java.lang.Object, :arglists ([coll x] [coll x & xs])} {:op :quote, :expr {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :type :symbol, :literal? true, :val two-fer, :form two-fer, :o-tag clojure.lang.Symbol, :tag clojure.lang.Symbol}, :form (quote two-fer), :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :literal? true, :children [:expr], :tag clojure.lang.Symbol, :o-tag clojure.lang.Symbol}], :children [:fn :args], :body? true, :fn {:op :var, :assignable? false, :var #'clojure.core/commute, :meta {:added "1.0", :ns #object[clojure.lang.Namespace 0x42ecc554 "clojure.core"], :name commute, :file "clojure/core.clj", :static true, :column 1, :line 2422, :arglists ([ref fun & args]), :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set."}, :env {:context :ctx/expr, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form clojure.core/commute, :o-tag java.lang.Object, :arglists ([ref fun & args])}, :op :invoke, :env {:context :ctx/return, :locals {}, :ns user, :once false, :loop-id loop_5141, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag java.lang.Object, :form (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer)), :raw-forms ((do (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))}}], :once false, :max-fixed-arity 0, :form (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer)))), :tag java.util.concurrent.Callable, :arglists ([]), :raw-forms ((clojure.core/fn [] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))}], :children [:args], :method runInTransaction, :op :static-call, :env {:context :ctx/statement, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :o-tag java.lang.Object, :class clojure.lang.LockingTransaction, :form (. clojure.lang.LockingTransaction (clojure.core/runInTransaction (clojure.core/fn [] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))), :tag java.lang.Object, :validated? true, :raw-forms ((clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))) (clojure.core/sync nil (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))}], :ret {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :type :nil, :literal? true, :val nil, :form nil, :o-tag nil, :tag nil}, :children [:statements :ret], :tag nil, :o-tag nil}, :children [:test :then :else], :o-tag nil}, :children [:statements :ret], :op :do, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :o-tag nil, :top-level true, :form (do (clojure.core/in-ns (quote two-fer)) (clojure.core/with-loading-context (clojure.core/refer (quote clojure.core))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))) nil))), :statements [{:op :invoke, :form (clojure.core/in-ns (quote two-fer)), :env {:context :ctx/statement, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :fn {:op :var, :assignable? false, :var #'clojure.core/in-ns, :meta {:doc "Sets *ns* to the namespace named by the symbol, creating it if needed.", :arglists ([name]), :name in-ns, :ns #object[clojure.lang.Namespace 0x42ecc554 "clojure.core"], :added "1.0"}, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :form clojure.core/in-ns, :o-tag java.lang.Object, :arglists ([name])}, :args [{:op :quote, :expr {:op :const, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :type :symbol, :literal? true, :val two-fer, :form two-fer, :o-tag clojure.lang.Symbol, :tag clojure.lang.Symbol}, :form (quote two-fer), :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :literal? true, :children [:expr], :tag clojure.lang.Symbol, :o-tag clojure.lang.Symbol}], :children [:fn :args], :o-tag java.lang.Object} {:op :invoke, :form ((clojure.core/fn loading__6721__auto__ [] (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})) (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))), :env {:context :ctx/statement, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :fn {:children [:local :methods], :op :fn, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :o-tag clojure.lang.AFunction, :variadic? false, :methods [{:children [:params :body], :loop-id loop_5140, :arglist [], :params [], :fixed-arity 0, :op :fn-method, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :file "NO_SOURCE_PATH"}, :o-tag java.lang.Object, :variadic? false, :form ([] (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})) (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))), :tag java.lang.Object, :body {:op :do, :env {:context :ctx/return, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form (do (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})) (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))), :statements [{:args [{:op :map, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :keys [{:field LOADER, :op :static-field, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag clojure.lang.Var, :class clojure.lang.Compiler, :form (. clojure.lang.Compiler -LOADER), :tag clojure.lang.Var, :assignable? false, :raw-forms (clojure.lang.Compiler/LOADER)}], :vals [{:args [], :children [:instance], :instance {:args [], :children [:instance], :instance {:children [], :name loading__6721__auto____#0, :op :local, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag clojure.lang.AFunction, :form loading__6721__auto__, :tag java.lang.Object, :atom #object[clojure.lang.Atom 0x24aedcc5 {:status :ready, :val {:tag clojure.lang.AFunction}}], :local :fn, :assignable? false}, :method getClass, :op :instance-call, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag java.lang.Class, :m-or-f getClass, :class java.lang.Object, :form (. loading__6721__auto__ getClass), :tag java.lang.Class, :validated? true, :raw-forms ((.getClass loading__6721__auto__))}, :method getClassLoader, :op :instance-call, :env {:context :ctx/expr, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag java.lang.ClassLoader, :m-or-f getClassLoader, :class java.lang.Class, :form (. (.getClass loading__6721__auto__) getClassLoader), :tag java.lang.ClassLoader, :validated? true, :raw-forms ((.getClassLoader (.getClass loading__6721__auto__)))}], :form #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}, :children [:keys :vals], :o-tag clojure.lang.PersistentHashMap, :tag clojure.lang.Associative}], :children [:args], :method pushThreadBindings, :op :static-call, :env {:context :ctx/statement, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :o-tag void, :class clojure.lang.Var, :form (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})), :tag void, :validated? true}], :ret {:op :try, :env {:context :ctx/return, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH"}, :form (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))), :body {:args [{:op :quote, :expr {:op :const, :env {:no-recur true, :loop-locals 0, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :loop-id loop_5140, :file "NO_SOURCE_PATH", :in-try true, :once false, :context :ctx/expr}, :type :symbol, :literal? true, :val clojure.core, :form clojure.core, :o-tag clojure.lang.Symbol, :tag clojure.lang.Symbol}, :form (quote clojure.core), :env {:no-recur true, :loop-locals 0, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :loop-id loop_5140, :file "NO_SOURCE_PATH", :in-try true, :once false, :context :ctx/expr}, :literal? true, :children [:expr], :tag clojure.lang.Symbol, :o-tag clojure.lang.Symbol}], :children [:fn :args], :body? true, :fn {:op :var, :assignable? false, :var #'clojure.core/refer, :meta {:arglists ([ns-sym & filters]), :doc "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", :added "1.0", :line 4217, :column 1, :file "clojure/core.clj", :name refer, :ns #object[clojure.lang.Namespace 0x42ecc554 "clojure.core"]}, :env {:no-recur true, :loop-locals 0, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :loop-id loop_5140, :file "NO_SOURCE_PATH", :in-try true, :once false, :context :ctx/expr}, :form clojure.core/refer, :o-tag java.lang.Object, :arglists ([ns-sym & filters])}, :op :invoke, :env {:no-recur true, :loop-locals 0, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :loop-id loop_5140, :file "NO_SOURCE_PATH", :in-try true, :once false, :context :ctx/return}, :o-tag java.lang.Object, :form (clojure.core/refer (quote clojure.core)), :raw-forms ((do (clojure.core/refer (quote clojure.core))))}, :catches [], :finally {:args [], :children [:args], :body? true, :method popThreadBindings, :op :static-call, :env {:context :ctx/statement, :locals {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}, :ns user, :once false, :loop-id loop_5140, :loop-locals 0, :file "NO_SOURCE_PATH", :no-recur true}, :o-tag void, :class clojure.lang.Var, :form (. clojure.lang.Var (clojure.core/popThreadBindings)), :tag void, :validated? true, :raw-forms ((do (. clojure.lang.Var (clojure.core/popThreadBindings))))}, :children [:body :catches :finally], :o-tag nil}, :children [:statements :ret], :body? true, :o-tag nil}, :local {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}], :once false, :max-fixed-arity 0, :form (fn* loading__6721__auto__ ([] (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})) (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))), :tag clojure.lang.AFunction, :arglists ([]), :local {:op :binding, :env {:context :ctx/expr, :locals {}, :ns user, :file "NO_SOURCE_PATH"}, :form loading__6721__auto__, :local :fn, :name loading__6721__auto____#0, :atom #object[clojure.lang.Atom 0x24aedcc5 {:status :ready, :val {:tag clojure.lang.AFunction}}], :tag clojure.lang.AFunction, :o-tag clojure.lang.AFunction}, :raw-forms ((clojure.core/fn loading__6721__auto__ [] (. clojure.lang.Var (clojure.core/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})) (try (clojure.core/refer (quote clojure.core)) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))))}, :args [], :children [:fn :args], :raw-forms ((clojure.core/with-loading-context (clojure.core/refer (quote clojure.core)))), :o-tag java.lang.Object}], :raw-forms ((ns two-fer))}